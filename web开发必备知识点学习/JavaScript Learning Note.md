# JavaScript Learning Note

[目前学习定位](https://wangdoc.com/javascript/types/function.html)

---

[TOC]

---


## 数据类型

### null, undefined和布尔值

* ==可以把undefined看作是空的变量，而null看作是空的对象。== 

### 数值

#### 5. 与数值相关的全局方法

##### 5.1 parseInt() -- 将字符串转成整数。

* `parseInt`的返回值只有两种可能，要么是一个十进制整数，要么是`NaN` 。
* 如果字符串以`0x`或`0X`开头，`parseInt`会将其按照十六进制数解析。 如果字符串以`0`开头，将其按照10进制解析。 
* `parseInt`方法还可以接受第二个参数（2到36之间），表示被解析的值的进制，返回该值对应的十进制数。默认情况下，`parseInt`的第二个参数为10，即默认是十进制转十进制。 

##### 5.2 parseFloat()  -- 将字符串转为浮点数

* 如果字符串符合科学计数法，则会进行相应的转换。 
* `parseFloat`会将空字符串转为`NaN`。 

##### 5.3 isNaN() -- `isNaN`方法可以用来判断一个值是否为`NaN`

* `isNaN`只对数值有效，如果传入其他值，会被先转成数值。比如，传入字符串的时候，字符串会被先转成`NaN`，所以最后返回`true`，这一点要特别引起注意。也就是说，`isNaN`为`true`的值，有可能不是`NaN`，而是一个字符串。 

* 对于空数组和只有一个数值成员的数组，`isNaN`返回`false`。 之所以返回`false`，原因是这些数组能被`Number`函数转成数值 .

* 因此，使用`isNaN`之前，最好判断一下数据类型。

  ```
  function myIsNaN(value) {
    return typeof value === 'number' && isNaN(value);
  }
  ```
* 判断NaN更可靠的方法是，利用NaN为唯一不等于自身的值的这个特点，进行判断。
  ```
  function myIsNaN(value) {
    return value !== value;
  }
  ```

##### 5.4 isFinite() -- 返回一个布尔值，表示某个值是否为正常的数值 

* 除了`Infinity`、`-Infinity`、`NaN`和`undefined`这几个值会返回`false`，`isFinite`对于其他的数值都会返回`true`。 

### 字符串

#### 1. 概述

##### 1.1 定义

* 单引号字符串的内部，可以使用双引号。双引号字符串的内部，可以使用单引号。 
* 如果要在单引号字符串的内部，使用单引号，就必须在内部的单引号前面加上反斜杠，用来转义。双引号字符串内部使用双引号，也是如此。 
* 由于 HTML 语言的属性值使用双引号，所以很多项目==约定 JavaScript 语言的字符串只使用单引号==
* 字符串默认只能写在一行内，分成多行将会报错 。如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠。 

```
var longString = 'Long \
long \
long \
string';

longString
// "Long long long string"
```

* 连接运算符（`+`）可以连接多个单行字符串，将长字符串拆成多行书写，输出的时候也是单行。 

##### 1.2 转义

反斜杠（\）在字符串内有特殊含义，用来表示一些特殊字符，所以又称为转义符。 

需要用反斜杠转义的特殊字符，主要有下面这些。

- `\0` ：null（`\u0000`）
- `\b` ：后退键（`\u0008`）
- `\f` ：换页符（`\u000C`）
- `\n` ：换行符（`\u000A`）
- `\r` ：回车键（`\u000D`）
- `\t` ：制表符（`\u0009`）
- `\v` ：垂直制表符（`\u000B`）
- `\'` ：单引号（`\u0027`）
- `\"` ：双引号（`\u0022`）
- `\\` ：反斜杠（`\u005C`）

上面这些字符前面加上反斜杠，都表示特殊含义。

如果字符串的正常内容之中，需要包含反斜杠，则反斜杠前面需要再加一个反斜杠，用来对自身转义。 

##### 1.3 字符串与数组

* ==字符串可以被视为字符数组==，因此可以使用数组的方括号运算符，用来返回某个位置的字符（位置编号从0开始）。 
* 但是，字符串与数组的相似性仅此而已。实际上，无法改变字符串之中的单个字符。 

##### 1.4 length属性

字符串的`length`属性无法改变 

#### 2. 字符集

* JavaScript 使用 Unicode 字符集。JavaScript 引擎内部，所有字符都用 Unicode 表示。 
* 允许直接在程序中使用 Unicode 码点表示字符，即将字符写成`\uxxxx`的形式，其中`xxxx`代表该字符的 Unicode 码点。比如，`\u00A9`代表版权符号。 

#### 3. Base64转码

JavaScript 原生提供两个 Base64 相关的方法。

- `btoa()`：任意值转为 Base64 编码
- `atob()`：Base64 编码转为原来的值

### 对象

#### 1. 概述

##### 1.1 生成方法

对象（object）是 JavaScript 语言的核心概念，也是最重要的数据类型。 

什么是对象？简单说，==对象就是一组“键值对”（key-value）的集合==，是一种无序的复合数据集合。 

```javascript
var obj = {
  foo: 'Hello',
  bar: 'World'
};
```

##### 1.2 键名

对象的所有键名都是字符串，所以==加不加引号都可以==。如果键名是数值，会被自动转为字符串。 

如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），且也不是数字，则必须加上引号，否则会报错。 

==对象的每一个键名又称为“属性”（property），它的“键值”可以是任何数据类型==。如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用。 

如果属性的值还是一个对象，就形成了链式引用。

```javascript
var o1 = {};
var o2 = { bar: 'hello' };

o1.foo = o2;
o1.foo.bar // "hello"
```

==对象的属性之间用逗号分隔==，最后一个属性后面可以加逗号（trailing comma），也可以不加。 

属性可以动态创建，不必在对象声明时就指定。

```javascript
var obj = {};
obj.foo = 123;
obj.foo // 123
```

##### 1.3 对象的引用

如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。 

但是，这种引用只局限于对象，如果两个变量指向同一个原始类型的值。那么，变量这时都是值的拷贝。 

```javascript
var x = 1;
var y = x;

x = 2;
y // 1
```

上面的代码中，当`x`的值发生变化后，`y`的值并不变，这就表示`y`和`x`并不是指向同一个内存地址。

##### 1.4 表达式还是语句？

V8 引擎规定，==如果行首是大括号，一律解释为对象==。不过，为了避免歧义，==最好在大括号前加上圆括号==。

```
({ foo: 123})
```

#### 2. 属性的操作

##### 2.1 属性的读取

读取对象的属性，有两种方法，一种是使用点运算符，还有一种是使用方括号运算符。

```JavaScript
var obj = {
  p: 'Hello World'
};

obj.p // "Hello World"
obj['p'] // "Hello World"，键名必须放在引号里面，否则会被当作变量处理
```

##### 2.2 属性的赋值

点运算符和方括号运算符，不仅可以用来读取值，还可以用来赋值。 

JavaScript 允许属性的“后绑定”，也就是说，你可以在任意时刻新增属性，没必要在定义对象的时候，就定义好属性。

```javascript
var obj = { p: 1 };

// 等价于

var obj = {};
obj.p = 1;
```

##### 2.3 属性的查看

查看一个对象本身的所有属性，可以使用`Object.keys`方法。

```javascript
var obj = {
  key1: 1,
  key2: 2
};

Object.keys(obj);
// ['key1', 'key2']
```

##### 2.4 属性的删除 -- delete命令

`delete`命令用于删除对象的属性，删除成功后返回`true`。 

需要注意的是，`delete`命令只能删除对象本身的属性，无法删除继承的属性 

==即使`delete`返回`true`，该属性依然可能读取到值。==

 ##### 2.5 属性是否存在 -- in运算符

`in`运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回`true`，否则返回`false`。它的左边是一个字符串，表示属性名，右边是一个对象。

```javascript
var obj = { p: 1 };
'p' in obj // true
'toString' in obj // true
```

`in`运算符的一个问题是，它不能识别哪些属性是对象自身的，哪些属性是继承的。就像上面代码中，对象obj本身并没有toString属性，但是in运算符会返回true，因为这个属性是继承的。 

可以使用对象的`hasOwnProperty`方法判断一下，是否为对象自身的属性。 

##### 2.6 属性的遍历 -- for...in 循环

`for...in`循环用来遍历一个对象的全部属性。

```javascript
var obj = {a: 1, b: 2, c: 3};

for (var i in obj) {
  console.log('键名：', i);
  console.log('键值：', obj[i]);
}
// 键名： a
// 键值： 1
// 键名： b
// 键值： 2
// 键名： c
// 键值： 3
```

`for...in`循环有两个使用注意点。

- 它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。
- 它不仅遍历对象自身的属性，还遍历继承的属性。

如果继承的属性是可遍历的，那么就会被`for...in`循环遍历到。但是，一般情况下，都是只想遍历对象自身的属性，所以使用`for...in`的时候，应该结合使用`hasOwnProperty`方法，在循环内部判断一下，某个属性是否为对象自身的属性。

```javascript
var person = { name: '老张' };

for (var key in person) {
  if (person.hasOwnProperty(key)) {
    console.log(key);
  }
}
// name
```

#### 3. with语句

`with`语句的格式如下：

```
with (对象) {
  语句;
}
```

它的作用是操作同一个对象的多个属性时，提供一些书写的方便。

注意，如果`with`区块内部有变量的赋值操作，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。

```javascript
var obj = {};
with (obj) {
  p1 = 4;
  p2 = 5;
}

obj.p1 // undefined
p1 // 4
```

==注意==，因为`with`区块没有改变作用域，它的内部依然是当前作用域。这造成了`with`语句的一个很大的弊病，就是绑定对象不明确。这非常不利于代码的除错和模块化，编译器也无法对这段代码进行优化，只能留到运行时判断，这就拖慢了运行速度。因此，==建议不要使用`with`语句，可以考虑用一个临时变量代替`with`。==

```javascript
with(obj1.obj2.obj3) {
  console.log(p1 + p2);
}

// 可以写成
var temp = obj1.obj2.obj3;
console.log(temp.p1 + temp.p2);
```

